-- ТРАНЗАКЦИИ

/*
Транзакция — это набор последовательных операций с базой данных, 
			соединенных в одну логическую единицу.

Транзакции делят на 2 вида:
1). Неявные транзакции, которые предусмотрены на уровне базы данных. 
Например, БД задает отдельную инструкцию INSERT, UPDATE или DELETE как единицу транзакции.
2). Явные транзакции — транзакции, которые мы задаем вручную. Их начало и конец 
явно обозначаются такими инструкциями, как BEGIN TRANSACTION, COMMIT или ROLLBACK(откат).

Существует 4 свойства транзакции:
1 свойство. Atomicity или атомарность (A) - либо все действия выполняются успешно, 
либо они НЕ будут выполнены вовсе.

2 свойство. Consistency или согласованность (C) - исходные данные останутся в том же состоянии 
после выполнения транзакции (они НЕ изменятся)

3 свойство. Isolation или изоляция (I) - если 2 и более операций транзакции в один 
момент времени начнут работать с одним и тем же набором данных, возникнет явление, 
называемое race condition (состояние гонки).  
Выделяют несколько эффектов, связанных с этим явлением
	
3.1. Эффект потерянного обновления - возникает, когда несколько транзакций обновляют 
одни и те же данные, не учитывая изменений, сделанных другими транзакциями.
    
Пример: Представим, что у клиента банка есть счет, на котором находится 
1000 денежных единиц. Транзакции А и В считывают данное значение из БД. 
Транзакция А должна увеличить данную суммуна 100 денежных единиц, а транзакция В — на 200. 
Транзакция А увеличивает сумму денежных единиц на счёте на 100 (итого 1100) и 
записывает значение в БД, транзакция В увеличивает сумму на 200 денежных единиц 
и записывает в БД (итого 1200). В результате на счете должно оказаться 1300,
а по факту имеем 1200 денежных единиц.

3.2. Эффект грязного чтения - возникает, когда транзакция считывает данные, 
которые еще не были зафиксированы.

Пример: Представим, что транзакция А переводит все деньги клиента на другой счет, 
но не фиксирует изменения. Транзакция В считывает изменения счёта А, 
получает 0 денежных единиц на счете и отказывает клиенту в выдаче наличных. 
Транзакция А прерывается и отменяет перевод между счетами.

3.3. Эффект неповторяемого чтения - возникает, когда транзакция считывает дважды 
одну и ту же строку, но каждый раз получает разные результаты.

Например, по правилу согласованности клиент банка не может иметь отрицательный баланс 
на счёте. Транзакция А хочет уменьшить баланс счета клиента на 200 денежных единиц. 
Она проверяет текущее значение суммы на счёте — 500 денежных единиц. 
В это время транзакция В уменьшает сумму на счёте до 0 и фиксирует изменения. 
Если бы транзакция А повторно проверила сумму, то получила бы 0 денежных единиц, 
но на основе первоначальных данных она уже приняла решение уменьшить значение, 
и счет уходит в минус.

3.4. Эффект чтения фантомов - возникает, когда набор данных соответствует условиям поиска, 
но изначально не отображается.

Например, правило согласованности запрещает иметь клиенту более 3 лицевых счетов. 
Для открытия нового счета транзакция А проверяет все счета клиента банка 
и в результате получает 2 счета. В этот момент транзакция B открывает еще один счет
клиенту и фиксирует изменения (3 счета). Если бы транзакция А повторно проверила 
количество лицевых счетов клиента, то их оказалось бы 3, и по правилу согласованности 
открытие нового счета было бы невозможно.

Изоляция — это свойство транзакции, которое позволяет скрывать изменения, 
внесенные одной операцией транзакции при возникновении явления race condition

Решения.
Для устранения эффектов на уровне баз данных предусмотрены уровни изоляции 
(transaction isolation levels).

1 решение. Read uncommitted – это уровень изоляции, при котором каждая транзакция 
видит незафиксированные изменения другой транзакции. 
Справляется с:
+ эффектом потерянного обновления

2 решение. Read committed — это уровень изоляции, при котором все действия выполняются 
параллельно, а исполняющиеся транзакции видят только зафиксированные изменения других транзакций. 
Справляется с:
+ эффектом потерянного обновления
+ эффектом грязного чтения,

3 решение. Repeatable read или snapshot isolation — это уровень изоляции, при котором 
транзакция не видит изменения данных, прочитанные ей ранее, однако способна прочитать 
новые данные, соответствующие условию поиска. 
Справляется с:
+ эффектом потерянного обновления, 
+ эффектом грязного чтения,
+ эффектом неповторяемого чтения

4 решение. Serializable — это уровень изоляции, при котором каждая транзакция выполняется 
так, как будто параллельных транзакций не существует. 
Справляется с:
+ эффектом потерянного обновления, 
+ эффектом грязного чтения,
+ эффектом неповторяемого чтения
+ эффектом чтения фантомов

4 свойство. Durability или долговечность (D) - если транзакция выполнена, и даже если 
в следующий момент произойдет сбой в системе, результат сохранится.

*/

# Пример транзакции

START TRANSACTION;    # начинаем транзакцию
SELECT total FROM accounts WHERE user_id = 2;
UPDATE accounts SET total = total - 3000 WHERE user_id = 2; # Снимаем средства со счета пользователя.
UPDATE accounts SET total = total + 3000 WHERE user_id IS NULL; # Перемещаем денежные средства на счет интернет-магазина.
COMMIT; # команда COMMIT, чтобы изменения вступили в силу


-- ВРЕМЕННАЯ ТАБЛИЦА

# Временная таблица - таблица, которая открыта во время сеанса в MySQL

CREATE TEMPORARY TABLE table_name 
(
column_1
column_2
);

# Преимущество временной таблицы - после завершения сеанса, 
# MySQL использует оператор, который удаляет её из системы.

# Т.е. временная табличка работает только во время активного сеанса
# и доступна только посетителю, который её использует.



-- ПЕРЕМЕННАЯ MySQL

# Переменная MySQL - используем для хранения данных в ячейках памяти.

# 1 cпособ создания переменной - SET
SET @counter1 := 100;     # присвоили переменной counter значенние 100
SELECT @counter1;         # вывод на экран

# 2 cпособ создания переменной - SELECT
SELECT @counter2 := 102;
SELECT @counter2;

# создаем переменную max_sale, в которую кладем max значение по столбцу sale
SELECT @max_sale:= MAX(sale)
FROM sales;


-- ОПЕРАТОР IF

SELECT IF (400 < 2000, 'YES', 'NO'); # true
# если условие верно, выполняется 1-ое действие ('YES')
# если неверно - 2-ое ('NO') 

SELECT IF (4000 < 2000, 'YES', 'NO'); # false

# Меняем  в таблице NULL на N/A (not avaible)
SELECT
	customerNumber,
    customerName,
    IF(state IS NULL, 'N/A', state) state, 
    country
FROM customers;
# если в столбце state значение NULL, тогда оно меняется на N/A, 
# если нет - то остается прежним

# IF + агрегатные функции
SELECT
	SUM(IF(Medium = 'cpc', 1, 0)) AS cpc,
	SUM(IF(Medium = 'cpa', 1, 0)) AS cpa    
FROM Orders;
    
  
-- Оператор COUNT IF
SELECT
	COUNT(IF(Medium = 'cpc', 1, NULL)) AS cpc,
	COUNT(IF(Medium = 'cpa', 1, NULL)) AS cpa,
	COUNT(IF(Medium = 'organic', 1, NULL)) AS organic,
	COUNT(IF(Medium = 'direct', 1, NULL)) AS direct
FROM Orders;

    
-- ПРОЦЕДУРА

# Процедура - это функция, которая ничего не возвращает    
# Синтаксис:
CREATE PROCEDURE procedure_name [(parameter datatype [, parameter datatype])]
BEGIN        # начало транзакции
	declaration_section
    executable_section
END;         # конец транзакции 

/*
- procedure_name - наименование процедуры в MySQL.
- parameter - необязательный. Один или несколько параметров передаются в процедуру. При создании процедуры могут
быть объявлены 3 типа параметров:
	1. IN - Параметр может ссылаться на процедуру. Значение параметра не может быть перезаписано процедурой.
	2. OUT - Параметр не может ссылаться на процедуру, но значение параметра может быть перезаписано процедурой.
	3. IN OUT - Параметр может ссылаться на процедуру, и значение параметра может быть перезаписано процедурой.
- declaration_section - место в процедуре, где вы объявляете локальные переменные.
- executable_section - место в процедуре, в котором вы создаете код процедуры 
(т.е. что она делает и какие операции выполняет)
*/


# Пример процедуры
# вывод машины, названия которых заканчиваются на букву n
DELIMITER &&  
CREATE PROCEDURE filter() 
BEGIN
	SELECT * 
    FROM cars 
    WHERE name LIKE '%n';
END &&
# была ошибка без строки DELIMITER && 
# процедура ничего нам не вернула, никакой вывод не получила 


-- ЦИКЛ WHILE

# задаем переменную счетчик i, которая по дефолту равна 3
# пока i > 0 выполняем код
# уменьшаем i на 1
DECLARE i INT DEFAULT 3; 
	WHILE i > 0 DO
		SELECT magazine_incoming.id_incoming, products.name, products.author
        FROM magazine_incoming, products
        WHERE magazine_incoming.id_product = products.id_product AND magazine_incoming.id_incoming = i;
        SET i = i - 1;
	END WHILE;



